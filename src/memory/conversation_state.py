\"\"\"Conversation state management for slot-filling dialogs.\"\"\"\n\nfrom typing import Dict, Any, List, Optional, Set\nimport json\n\nclass ConversationState:\n    \"\"\"Manages the state of a slot-filling conversation.\"\"\"\n    \n    def __init__(self):\n        \"\"\"Initialize a new conversation state.\"\"\"\n        self.slots: Dict[str, Any] = {}\n        self.required_slots: Set[str] = {\n            \"category\",           # Project category (repair, renovation, etc.)\n            \"job_type\",          # Specific job type\n            \"location\",          # Where work will be performed\n            \"budget_range\",      # Budget expectations\n            \"timeline\",          # When work should be done\n            \"description\"        # Detailed project description\n        }\n        self.slot_questions: Dict[str, str] = {\n            \"category\": \"What type of project are you looking for? (repair, renovation, installation, maintenance, or construction)\",\n            \"job_type\": \"What specific job are you looking to have done?\",\n            \"location\": \"Where will this work be performed? (Which room or area of your home?)\",\n            \"budget_range\": \"Do you have a budget range in mind for this project?\",\n            \"timeline\": \"When would you like this project to be completed?\",\n            \"description\": \"Can you provide some additional details about your project?\"\n        }\n        self.slot_priorities: Dict[str, int] = {\n            \"category\": 1,\n            \"job_type\": 2,\n            \"location\": 3,\n            \"description\": 4,\n            \"budget_range\": 5,\n            \"timeline\": 6\n        }\n        self.user_inputs: List[str] = []\n    \n    def add_user_input(self, user_input: str) -> None:\n        \"\"\"Add user input to the conversation history.\"\"\"\n        self.user_inputs.append(user_input)\n        self._extract_slots_from_input(user_input)\n    \n    def _extract_slots_from_input(self, user_input: str) -> None:\n        \"\"\"Extract slot values from user input using simple heuristics.\"\"\"\n        # Simple keyword-based extraction (to be improved with NLP)\n        text = user_input.lower()\n        \n        # Category extraction\n        if \"repair\" in text:\n            self.slots[\"category\"] = \"repair\"\n        elif \"renovat\" in text or \"remodel\" in text:\n            self.slots[\"category\"] = \"renovation\"\n        elif \"install\" in text:\n            self.slots[\"category\"] = \"installation\"\n        elif \"maintenance\" in text or \"clean\" in text or \"service\" in text:\n            self.slots[\"category\"] = \"maintenance\"\n        elif \"build\" in text or \"construct\" in text:\n            self.slots[\"category\"] = \"construction\"\n        \n        # Budget extraction - look for dollar amounts\n        import re\n        budget_pattern = r'\\$?(\\d{1,3}(?:,\\d{3})*|\\d+)(?:\\.\\d+)?\\s*(?:k|thousand|K)?'\n        budget_matches = re.findall(budget_pattern, text)\n        if budget_matches:\n            # Convert to numeric value\n            try:\n                amount = budget_matches[0].replace(',', '')\n                # Handle 'k' or 'thousand' suffix\n                if 'k' in text or 'thousand' in text:\n                    amount = float(amount) * 1000\n                self.slots[\"budget_range\"] = f\"${amount}\"\n            except ValueError:\n                pass\n        \n        # Timeline extraction - look for dates or time references\n        if any(word in text for word in [\"urgent\", \"emergency\", \"immediately\", \"asap\"]):\n            self.slots[\"timeline\"] = \"Urgent / ASAP\"\n        elif any(word in text for word in [\"week\", \"weeks\"]):\n            self.slots[\"timeline\"] = \"Within weeks\"\n        elif any(word in text for word in [\"month\", \"months\"]):\n            self.slots[\"timeline\"] = \"Within months\"\n        \n        # Location extraction - look for room names\n        rooms = [\"bathroom\", \"kitchen\", \"bedroom\", \"living room\", \"basement\", \n                \"attic\", \"garage\", \"yard\", \"driveway\", \"roof\", \"outside\", \"exterior\"]\n        for room in rooms:\n            if room in text:\n                self.slots[\"location\"] = room.title()\n                break\n        \n        # If no specific slots were extracted, set the description if empty\n        if \"description\" not in self.slots and user_input.strip():\n            self.slots[\"description\"] = user_input\n    \n    def get_next_slot(self) -> Optional[str]:\n        \"\"\"Get the next slot that needs to be filled, based on priority.\"\"\"\n        missing_slots = self.required_slots - set(self.slots.keys())\n        if not missing_slots:\n            return None\n            \n        # Return the highest priority missing slot\n        return min(missing_slots, key=lambda slot: self.slot_priorities.get(slot, 999))\n    \n    def get_question_for_slot(self, slot: str) -> str:\n        \"\"\"Get the question to ask for a specific slot.\"\"\"\n        return self.slot_questions.get(slot, f\"Can you tell me about the {slot}?\")\n    \n    def is_complete(self) -> bool:\n        \"\"\"Check if all required slots are filled.\"\"\"\n        return self.required_slots.issubset(set(self.slots.keys()))\n    \n    def get_slots(self) -> Dict[str, Any]:\n        \"\"\"Get all filled slots.\"\"\"\n        return self.slots\n    \n    def to_json(self) -> str:\n        \"\"\"Convert state to JSON for storage.\"\"\"\n        return json.dumps({\n            \"slots\": self.slots,\n            \"user_inputs\": self.user_inputs\n        })\n    \n    @classmethod\n    def from_json(cls, json_str: str) -> 'ConversationState':\n        \"\"\"Create state object from JSON.\"\"\"\n        state = cls()\n        data = json.loads(json_str)\n        state.slots = data.get(\"slots\", {})\n        state.user_inputs = data.get(\"user_inputs\", [])\n        return state