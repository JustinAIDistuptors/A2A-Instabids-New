Sprint 4: Workflow Visualization – Agent Process Flow & State Management
Deliverables: Provide transparency into the agent’s internal processes by visualizing the workflow or steps the agent takes for tasks like bidding. Also introduce a more robust state management system to handle real-time updates from the agent. By the end, users will be able to see a live outline of the agent’s decision-making or bidding steps, and the UI will dynamically update as the agent progresses.
Components & Files: Develop features to make the agent’s work visible and trackable in the UI:
Agent Workflow Visualizer: Create a component (e.g., AgentWorkflow.tsx) that can display a sequence of steps or tasks that the agent is performing. For example:
Represent each step in the agent’s plan (like “Searching listings -> Analyzing prices -> Placing bid -> Awaiting result”) as an item in a timeline or an accordion. A Shadcn UI Accordion or Timeline styled component can be used here, showing each step with a title and maybe expandable details.
If the agent’s process is linear, a simple vertical list with icons (using something like Radix UI Progress or just step indicators) can suffice. If it's branching or involves multiple agents (in future, A2A interactions), design it in a way that could be extended (but for now, focus on the linear sequence).
The component should highlight the current step the agent is on (e.g., bold or with a spinner icon next to it), and possibly mark completed steps with a checkmark or green indicator. Future steps can be grayed out until reached.
Place this component in context: for instance, on the bid detail page, show the workflow of the agent fulfilling that bid. Or on the main dashboard, show the workflow for the most recent agent task.
Global State Management: Introduce a state management solution to coordinate data across components (consider using React Context, Zustand, Redux, or the built-in React Server Components patterns if on Next.js 13+):
Create a centralized store or context for agent state and updates. For example, an AgentContext could hold info about current tasks, their progress, and agent status.
Ensure that when the agent sends new info (like a new step completed or an update on a bid), the state updates and the relevant UI (workflow component, status badge, bid list) refreshes automatically.
This state management will integrate with real-time updates from the backend (see integration below). It might involve setting up a WebSocket or Server-Sent Events listener in a global context that pushes updates to the store.
“Agent Thinking” Indicators: Expand the agent status concept to more places:
Within the chat interface, if the agent is performing a multi-step operation (not just formulating a text reply), indicate that to the user (e.g., “Agent is working on your request…” message or disable the input temporarily with a spinner).
Possibly overlay a small loading indicator on the Agent’s avatar or status badge when busy. Ensure this is consistent with the Workflow Visualizer (which is a more detailed view of what’s happening).
If multiple agents or threads were to be handled, the UI should show parallel workflows or some identification of which agent is thinking (for now, assume one primary agent).
Backend/Agent Integration: Achieve real-time updates from the agent to feed the workflow UI:
Event Streaming: If not already used, implement a channel for the backend to push events. Options:
WebSockets: If the FastAPI backend supports a WebSocket endpoint (e.g., /ws), the frontend can connect after user login. The backend can emit events like {"bidId": 123, "step": "Analyzing prices", "status": "in_progress"} as the agent works. The frontend’s state manager receives these and updates the AgentWorkflow component.
Server-Sent Events (SSE): Alternatively, use SSE to listen for agent updates if WebSockets are not available. The Vercel AI SDK’s useChat already handles SSE for chat; you might create a custom hook or utilize a similar approach for general events.
Polling (fallback): If real-time push is not easily done yet, implement short-polling as a fallback. E.g., every X seconds, call an endpoint like /bids/{id}/status to get updated progress. This is less efficient but ensures the UI stays updated. Plan to replace this with true real-time as the platform matures.
Define Event Schema: Coordinate with the backend team on the structure of agent progress events. Ensure the frontend knows how to interpret them (which bid or task they refer to, what stage). Possibly have a shared enum of stages or messages so that the UI can display friendly names.
State Synchronization: On receiving an event (via WS or SSE), update the global state. For example, if an event says “bid 123 step 2 complete, moving to step 3”, mark step 2 as done and step 3 as active in the AgentWorkflow for bid 123. Also update any related data (maybe the bid’s status from “In Progress” to “Completed” when final step finishes).
Continue handling error cases: if the agent encounters an error in a step, the backend should send an error event – decide how to display that (perhaps mark the step as failed with a red icon and notify the user, which ties into Sprint 5’s notifications).
Tests: Testing real-time and stateful features:
Unit Tests:
For the AgentWorkflow component, test rendering logic: given a mock list of steps and a current step index, ensure it highlights the correct step and displays all steps in order. Test that completed steps show as completed (you might simulate prop changes to mimic progress).
For the state management (if using a Redux store or context), write tests for the reducer or context updater: feed it sample events (like an action “STEP_COMPLETED” with data) and assert that the state transitions correctly (e.g., the relevant step’s status becomes completed).
If a custom hook is written for connecting to events (e.g., useAgentEvents), consider using a mocked WebSocket in tests to trigger incoming messages and verify the state or UI updates.
Integration Tests: These can be tricky for real-time, but you can simulate events:
Use Cypress (with a plugin or just stub in-app methods) to simulate the backend events. For instance, start the app and programmatically dispatch an event into the global store (maybe expose a test-only button or use the browser console via Cypress to call the event handler).
Verify that the workflow timeline updates on the UI without a page refresh. For example, if you simulate the agent moving to step 2, the UI should show step 1 done, step 2 active.
Test that starting a bid (from Sprint 3’s form) triggers the workflow display. Possibly, chain the tests: create a new bid, then simulate events for that bid’s progress, and ensure the UI shows those steps.
Ensure backward compatibility: the app should still function if no real-time updates come (e.g., if the agent is idle or if an older part of the system doesn’t emit events). The workflow might just remain static or hidden in that case, which is fine.
Continue to run full test suite; the introduction of real-time logic means tests must be robust against timing issues (use appropriate waits in Cypress, etc.).
DevOps & GitHub Actions: Work in a branch (e.g. ui/agent-workflow). Given the complexity:
Commit in logical chunks (e.g., feat(ui): add agent workflow timeline component, feat(ui): integrate WebSocket for agent events, refactor: centralize agent state management).
Ensure that the development and test environment can handle WebSockets or SSE. For CI, you may need to mock out the real-time connection (perhaps run a dummy WebSocket server during tests or adjust tests to not require an actual WS).
The CI pipeline should run all tests including the new ones. If any flakiness occurs due to timing in tests, adjust the tests or environment (for example, set a deterministic mode for event simulation).
After merging, verify on the deployed environment that the app successfully connects to the backend events (might require configuring the correct backend URL for WS in production). This sprint completes a major feature, so consider tagging a pre-release (e.g., v0.1 of the UI) for internal review.
